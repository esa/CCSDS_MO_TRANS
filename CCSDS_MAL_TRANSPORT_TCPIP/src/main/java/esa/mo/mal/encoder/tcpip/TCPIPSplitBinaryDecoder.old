package esa.mo.mal.encoder.tcpip;

import java.io.InputStream;
import java.util.List;

import org.ccsds.moims.mo.mal.MALException;
import org.ccsds.moims.mo.mal.structures.Blob;
import org.ccsds.moims.mo.mal.structures.Identifier;
import org.ccsds.moims.mo.mal.structures.UInteger;
import org.ccsds.moims.mo.mal.structures.URI;

import esa.mo.mal.encoder.binary.split.SplitBinaryDecoder;

/**
 * The TCPIPSplitBinaryDecoder modifies the default SplitBinaryDecoder behaviour
 * by reading string lengths as unsigned 4-octet varints, as specified in
 * standard CCSDS 524.2-R-1.
 * 
 * @author Rian van Gijlswijk <r.vangijlswijk@telespazio-vega.de>
 *
 */
public class TCPIPSplitBinaryDecoder extends SplitBinaryDecoder {

	/**
	 * Constructor.
	 *
	 * @param src
	 *            Byte array to read from.
	 */
	public TCPIPSplitBinaryDecoder(final byte[] src) {
		super(new TCPIPSplitBinaryBufferHolder(null, src, 0, src.length));
	}

	/**
	 * Constructor.
	 *
	 * @param is
	 *            Input stream to read from.
	 */
	public TCPIPSplitBinaryDecoder(final java.io.InputStream is) {
		super(new TCPIPSplitBinaryBufferHolder(is, null, 0, 0));
	}

	/**
	 * Constructor.
	 *
	 * @param src
	 *            Byte array to read from.
	 * @param offset
	 *            index in array to start reading from.
	 */
	public TCPIPSplitBinaryDecoder(final byte[] src, final int offset) {
		super(new TCPIPSplitBinaryBufferHolder(null, src, offset, src.length));
	}

	/**
	 * Constructor.
	 *
	 * @param src
	 *            Source buffer holder to use.
	 */
	protected TCPIPSplitBinaryDecoder(final BufferHolder src) {
		super(src);
	}
	
//	@Override
//	public UInteger decodeUInteger() throws MALException {
//
//		return new UInteger(sourceBuffer.getUnsignedInt());
//	}

//	public org.ccsds.moims.mo.mal.MALListDecoder createListDecoder(final List list) throws MALException {
//		return new TCPIPSplitBinaryListDecoder(list, sourceBuffer);
//	}

	@Override
	public String decodeString() throws MALException {
		
		int sz = ((TCPIPSplitBinaryBufferHolder) sourceBuffer).getUnsignedVarint4();
//		int sz = sourceBuffer.getUnsignedInt();
		
		System.out.print("String decode sz=" + sz + " ");
		
		if (sz >= 0) {

			((SplitBufferHolder)sourceBuffer).checkBuffer(sz);
			
			final String s = new String(sourceBuffer.directGetBytes(sz),UTF8_CHARSET);
			System.out.println(" val " + s);
			return s;
		}
		
		return null;		
	}
	
	@Override
	public Blob decodeBlob() throws MALException {
		
		int sz = ((TCPIPSplitBinaryBufferHolder) sourceBuffer).getUnsignedVarint4();
//		int sz = (int)decodeUInteger().getValue();
		
		System.out.println("Blob decode sz=" + sz);
		
		if (sz == 0) {
			return null;
		}
		
		return new Blob(sourceBuffer.directGetBytes(sz));
	}
	
	@Override
	public String decodeNullableString() throws MALException {
		
		// decode presence flag
		boolean isNotNull = decodeBoolean();
			
		// decode one element, or add null if presence flag indicates no element
		if (isNotNull) {
			return decodeString();
		}
	
		return null;
	}
	
	@Override
	public Blob decodeNullableBlob() throws MALException {
		
		// decode presence flag
		boolean isNotNull = decodeBoolean();
			
		// decode one element, or add null if presence flag indicates no element
		if (isNotNull) {
			return decodeBlob();
		}
	
		return null;
	}

//	@Override
//	public Identifier decodeIdentifier() throws MALException {
//		return new Identifier(decodeString());
//	}

//	@Override
//	public Identifier decodeNullableIdentifier() throws MALException {
//
//		// decode presence flag
//		boolean isNotNull = decodeBoolean();
//			
//		// decode one element, or add null if presence flag indicates no element
//		if (isNotNull) {
//			return decodeIdentifier();
//		}
//	
//		return null;
//	}
//
//	@Override
//	public URI decodeNullableURI() throws MALException {
//
//		// decode presence flag
//		boolean isNotNull = decodeBoolean();
//			
//		// decode one element, or add null if presence flag indicates no element
//		if (isNotNull) {
//			return decodeURI();
//		}
//	
//		return null;
//	}

	protected static class TCPIPSplitBinaryBufferHolder extends SplitBufferHolder {

		public TCPIPSplitBinaryBufferHolder(InputStream is, byte[] buf, int offset,
				int length) {
			super(is, buf, offset, length);
		}

		// TODO: This fails in Testbed, works only if string length is stored as signed
		// integer. Sometimes, length == -1? According to specs, must be stored as unsigned however
//		@Override
//		public String getString() throws MALException {
//			
//			int sz = getUnsignedVarint4();
//			
//			System.out.print("TCPIPSplitBinaryDecoder.getString: sz=" + sz + " val=");
//			
//			if (sz == 0) {
//				return null;
//			}
//			
//			String output = new String(directGetBytes(sz));
//			
//			System.out.println(output);
//			
//			return output;
//		}
		
		/**
		 * Decode an unsigned int using a split-binary approach
		 */
		public int getUnsignedVarint4() throws MALException {
			
			int value = 0;
			int i = 0;
			int b;
			while (((b = get8()) & 0x80) != 0) {
				value |= (b & 0x7F) << i;
				i += 7;
			}
			return value | (b << i);
		}

	}
}
